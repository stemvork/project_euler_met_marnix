# k terms of a sequence
# u_n = n^3 -- 1, 8, 27, 64, 125, 216

# based on two terms = linear -- 1, 8, 15
# then the third term is wrong (27)

# OP(k,n) is the nth term of the optimum polynomial (g.f.)
# where g.f. is generating function
# OP(k,n) generates first k terms accurately
# OP(k,k+1) first incorrect term (FIT) potentially
# if indeed, OP(k,k+1) is FIT then OP is bad (BOP)

# OP(1,n) = 1               -- 1,_1_,1,1,...
# OP(2,n) = 7n - 6          -- 1,8,_15_,...
# OP(3,n) = 6n^2 - 11n + 6  -- 1,8,27,_58_,...
# OP(4,n) = n^3             -- 1,8,27,64,125,...
# i.e. no BOPS for k \geq 4

# sum of FITs generated by BOPs are 1 + 15 + 58 = 74

# consider tenth degree polynomial generating function
# u_n = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^{10}
# task: find the sum of the FITs for the BOPs

# resource: https://stackoverflow.com/questions/14823891/newton-s-interpolating-polynomial-python
import numpy as np
def _poly_newton_coefficient(x, y):
    m = len(x)
    x = np.copy(x)
    a = np.copy(y)
    for k in range(1,m):
        a[k:m] = (a[k:m] - a[k-1])/(x[k:m] - x[k-1])
    return a

def newton_polynomial(x_data, y_data, x):
    a = _poly_newton_coefficient(x_data, y_data)
    n = len(x_data) - 1
    p = a[n]
    for k in range(1, n+1):
        p = a[n-k] + (x - x_data[n-k]) * p
    return p

def polynomial(x, *a):
    value = 0
    for i, e in enumerate(a):
        value += x**i * e
    return value

def tenth(x):
    return polynomial(x, 1, -1, 1, -1, 1, -1, 1, -1, 1, -1, 1)

x_data = np.array(list(range(11)[1:]))
y_data = np.array(list(map(tenth, x_data)))
s = 0
for i in range(11)[1:]:
    xs = x_data[:i]
    ys = y_data[:i]
    x = 1
    y = 1
    while y == tenth(x):
        x += 1
        y = newton_polynomial(xs, ys, x)
        print(f"[{i}]: ({x}, {y})")
        if y != tenth(x) and x > i:
            print("BOP with FIT", y)
            s += y
print(s)

# Theory from Wikipedia:
# Based on the points (x_0, y_0), (x_1, y_1), ..., (x_j, y_j), ..., (x_k, y_k) where no two x_j are the same, the Newton interpolation polynomial is a linear combination of Newton basis polynomials: N(x) = sum_{j=0}^k a_j * n_j(x) with the Newton basis polynomials defined as n_j(x) = product_{i=0}^{j-1} (x - x_i) for j > 0 and n_0(x) = 1.
#
# The coefficients a_j are defined as [y_0, ..., y_j] which is a notation for divided differences.
#
# e.g. N(x) = y_0 + (y_1-y_0)/(x_1-x_0) * (x - x_0) + ((y_2-y_1)/(x_2-x_1) -(y_1-y_0)/(x_1-x_0))/(x_2-x_0) * (x - x_0)(x - x_1) for k=2
#
# Exploring the example :
# O(2, n) uses two terms (1, 8) to generate: 
# 	P(1) = 7 - 6 = 1
# 	P(2) = 14 - 6 = 8
# 	P(3) = 21 - 6 = 15 (BOP)
# 
# O(3, n) uses three terms (1, 8, 27) to generate:
# 	P(1) = 6 - 11 + 6 = 12 - 11 = 1
# 	P(2) = 6 * 4 - 11 * 2 + 6 = 24 - 22 + 6 = 30 - 22 = 8
# 	P(3) = 6 * 9 - 11 * 3 + 6 = 54 - 33 + 6 = 60 - 33 = 27
# 	P(4) = 6 * 16 - 11 * 4 + 6 = 96 - 44 + 6 = 102 - 44 = 58 (BOP)
